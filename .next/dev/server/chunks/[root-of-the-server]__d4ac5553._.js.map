{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Leonardo%20Machado/Documents/Planeamento%20dental/planeamento-dental/src/lib/api-shared/auth.ts"],"sourcesContent":["import type { VercelRequest, VercelResponse } from '@vercel/node'\r\nimport jwt from 'jsonwebtoken'\r\n\r\nexport interface AuthRequest extends VercelRequest {\r\n  user?: {\r\n    id: string\r\n    email: string\r\n    role: 'admin' | 'user'\r\n    clinicId?: string\r\n    name: string\r\n  }\r\n}\r\n\r\n// Usar variável de ambiente ou fallback\r\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production'\r\n\r\nif (!process.env.JWT_SECRET) {\r\n  console.warn('⚠️  JWT_SECRET não configurado! Usando valor padrão inseguro.')\r\n}\r\n\r\nexport function authenticateToken(\r\n  req: AuthRequest,\r\n  res: VercelResponse,\r\n  next: () => void\r\n) {\r\n  const authHeader = req.headers['authorization']\r\n  const token = authHeader && authHeader.split(' ')[1]\r\n\r\n  if (!token) {\r\n    return res.status(401).json({ error: 'Token não fornecido' })\r\n  }\r\n\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET) as AuthRequest['user']\r\n    req.user = decoded\r\n    next()\r\n  } catch (error) {\r\n    return res.status(403).json({ error: 'Token inválido ou expirado' })\r\n  }\r\n}\r\n\r\nexport function requireAdmin(\r\n  req: AuthRequest,\r\n  res: VercelResponse,\r\n  next: () => void\r\n) {\r\n  if (req.user?.role !== 'admin') {\r\n    return res.status(403).json({ error: 'Acesso negado. Admin necessário.' })\r\n  }\r\n  next()\r\n}\r\n\r\nexport function optionalAuth(\r\n  req: AuthRequest,\r\n  res: VercelResponse,\r\n  next: () => void\r\n) {\r\n  const authHeader = req.headers['authorization']\r\n  const token = authHeader && authHeader.split(' ')[1]\r\n\r\n  if (token) {\r\n    try {\r\n      const decoded = jwt.verify(token, JWT_SECRET) as AuthRequest['user']\r\n      req.user = decoded\r\n    } catch (error) {\r\n      // Token inválido, mas continua sem autenticação\r\n    }\r\n  }\r\n  next()\r\n}\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":";;;;;;;;AACA;;AAYA,wCAAwC;AACxC,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAE7C,IAAI,CAAC,QAAQ,GAAG,CAAC,UAAU,EAAE;IAC3B,QAAQ,IAAI,CAAC;AACf;AAEO,SAAS,kBACd,GAAgB,EAChB,GAAmB,EACnB,IAAgB;IAEhB,MAAM,aAAa,IAAI,OAAO,CAAC,gBAAgB;IAC/C,MAAM,QAAQ,cAAc,WAAW,KAAK,CAAC,IAAI,CAAC,EAAE;IAEpD,IAAI,CAAC,OAAO;QACV,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAAsB;IAC7D;IAEA,IAAI;QACF,MAAM,UAAU,+NAAG,CAAC,MAAM,CAAC,OAAO;QAClC,IAAI,IAAI,GAAG;QACX;IACF,EAAE,OAAO,OAAO;QACd,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAA6B;IACpE;AACF;AAEO,SAAS,aACd,GAAgB,EAChB,GAAmB,EACnB,IAAgB;IAEhB,IAAI,IAAI,IAAI,EAAE,SAAS,SAAS;QAC9B,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAAmC;IAC1E;IACA;AACF;AAEO,SAAS,aACd,GAAgB,EAChB,GAAmB,EACnB,IAAgB;IAEhB,MAAM,aAAa,IAAI,OAAO,CAAC,gBAAgB;IAC/C,MAAM,QAAQ,cAAc,WAAW,KAAK,CAAC,IAAI,CAAC,EAAE;IAEpD,IAAI,OAAO;QACT,IAAI;YACF,MAAM,UAAU,+NAAG,CAAC,MAAM,CAAC,OAAO;YAClC,IAAI,IAAI,GAAG;QACb,EAAE,OAAO,OAAO;QACd,gDAAgD;QAClD;IACF;IACA;AACF"}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Leonardo%20Machado/Documents/Planeamento%20dental/planeamento-dental/src/lib/api-shared/db.ts"],"sourcesContent":["// Módulo compartilhado para API routes\r\n// Este arquivo só roda no servidor (Node.js)\r\n\r\nimport { Pool } from 'pg'\r\n\r\n// Validar DATABASE_URL\r\nif (!process.env.DATABASE_URL) {\r\n  console.error('❌ DATABASE_URL não está configurada!')\r\n  console.error('❌ Configure DATABASE_URL no arquivo .env.local ou nas variáveis de ambiente')\r\n  throw new Error('DATABASE_URL não configurada. Configure no .env.local ou variáveis de ambiente.')\r\n}\r\n\r\n// Pool de conexões PostgreSQL\r\nconst pool = new Pool({\r\n  connectionString: process.env.DATABASE_URL,\r\n  ssl: {\r\n    rejectUnauthorized: false,\r\n  },\r\n  max: 20,\r\n  idleTimeoutMillis: 30000,\r\n  connectionTimeoutMillis: 2000,\r\n})\r\n\r\npool.on('connect', () => {\r\n  console.log('✅ Conectado ao banco de dados Neon')\r\n})\r\n\r\npool.on('error', (err) => {\r\n  console.error('❌ Erro no pool de conexões:', err)\r\n})\r\n\r\nexport default pool\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":";;;;AAAA,uCAAuC;AACvC,6CAA6C;AAE7C;;;;;;AAEA,uBAAuB;AACvB,IAAI,CAAC,QAAQ,GAAG,CAAC,YAAY,EAAE;IAC7B,QAAQ,KAAK,CAAC;IACd,QAAQ,KAAK,CAAC;IACd,MAAM,IAAI,MAAM;AAClB;AAEA,8BAA8B;AAC9B,MAAM,OAAO,IAAI,qMAAI,CAAC;IACpB,kBAAkB,QAAQ,GAAG,CAAC,YAAY;IAC1C,KAAK;QACH,oBAAoB;IACtB;IACA,KAAK;IACL,mBAAmB;IACnB,yBAAyB;AAC3B;AAEA,KAAK,EAAE,CAAC,WAAW;IACjB,QAAQ,GAAG,CAAC;AACd;AAEA,KAAK,EAAE,CAAC,SAAS,CAAC;IAChB,QAAQ,KAAK,CAAC,+BAA+B;AAC/C;uCAEe"}},
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Leonardo%20Machado/Documents/Planeamento%20dental/planeamento-dental/src/lib/api-shared/staleTracking.ts"],"sourcesContent":["// Função para marcar relatórios como stale quando dados são alterados\r\nimport pool from './db'\r\n\r\n/**\r\n * Marca relatórios de uma seção como stale\r\n */\r\nexport async function markSectionReportsAsStale(\r\n  dossierId: string,\r\n  sectionCode: string,\r\n): Promise<void> {\r\n  try {\r\n    await pool.query(\r\n      `UPDATE ai_reports \r\n       SET status = 'stale', updated_at = NOW()\r\n       WHERE dossier_id = $1 AND section_code = $2 AND status = 'generated'`,\r\n      [dossierId, sectionCode],\r\n    )\r\n  } catch (error) {\r\n    console.error('Erro ao marcar relatórios como stale:', error)\r\n    // Não lançar erro para não quebrar o fluxo principal\r\n  }\r\n}\r\n\r\n/**\r\n * Determina a seção afetada por uma entidade\r\n */\r\nexport function getSectionForEntity(entityType: string): string | null {\r\n  const entitySectionMap: Record<string, string> = {\r\n    customer_segments: 'IDENTITY',\r\n    value_propositions: 'IDENTITY',\r\n    competitors: 'MARKET',\r\n    service_categories: 'OFFER',\r\n    services: 'OFFER',\r\n    team_members: 'OPERATIONS',\r\n    roles: 'OPERATIONS',\r\n    capacities: 'OPERATIONS',\r\n    strategic_choices: 'STRATEGY',\r\n    initiatives: 'PLAN',\r\n  }\r\n\r\n  return entitySectionMap[entityType] || null\r\n}\r\n\r\n/**\r\n * Determina a seção afetada por uma pergunta (via question_set)\r\n */\r\nexport async function getSectionForQuestion(questionId: string): Promise<string | null> {\r\n  try {\r\n    const result = await pool.query(\r\n      `SELECT s.code \r\n       FROM sections s\r\n       JOIN question_sets qs ON qs.section_id = s.id\r\n       JOIN questions q ON q.question_set_id = qs.id\r\n       WHERE q.id = $1`,\r\n      [questionId],\r\n    )\r\n\r\n    if (result.rows.length > 0) {\r\n      return result.rows[0].code\r\n    }\r\n  } catch (error) {\r\n    console.error('Erro ao buscar seção da pergunta:', error)\r\n  }\r\n\r\n  return null\r\n}\r\n\r\n/**\r\n * Marca o relatório final como stale quando qualquer seção fica stale\r\n */\r\nexport async function markFinalReportAsStale(dossierId: string): Promise<void> {\r\n  try {\r\n    await pool.query(\r\n      `UPDATE ai_reports \r\n       SET status = 'stale', updated_at = NOW()\r\n       WHERE dossier_id = $1 AND section_code = 'FINAL_REPORT' AND status = 'generated'`,\r\n      [dossierId],\r\n    )\r\n  } catch (error) {\r\n    console.error('Erro ao marcar relatório final como stale:', error)\r\n    // Não lançar erro para não quebrar o fluxo principal\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;AAAA,sEAAsE;AACtE;;;;;;AAKO,eAAe,0BACpB,SAAiB,EACjB,WAAmB;IAEnB,IAAI;QACF,MAAM,qLAAI,CAAC,KAAK,CACd,CAAC;;2EAEoE,CAAC,EACtE;YAAC;YAAW;SAAY;IAE5B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yCAAyC;IACvD,qDAAqD;IACvD;AACF;AAKO,SAAS,oBAAoB,UAAkB;IACpD,MAAM,mBAA2C;QAC/C,mBAAmB;QACnB,oBAAoB;QACpB,aAAa;QACb,oBAAoB;QACpB,UAAU;QACV,cAAc;QACd,OAAO;QACP,YAAY;QACZ,mBAAmB;QACnB,aAAa;IACf;IAEA,OAAO,gBAAgB,CAAC,WAAW,IAAI;AACzC;AAKO,eAAe,sBAAsB,UAAkB;IAC5D,IAAI;QACF,MAAM,SAAS,MAAM,qLAAI,CAAC,KAAK,CAC7B,CAAC;;;;sBAIe,CAAC,EACjB;YAAC;SAAW;QAGd,IAAI,OAAO,IAAI,CAAC,MAAM,GAAG,GAAG;YAC1B,OAAO,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI;QAC5B;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,qCAAqC;IACrD;IAEA,OAAO;AACT;AAKO,eAAe,uBAAuB,SAAiB;IAC5D,IAAI;QACF,MAAM,qLAAI,CAAC,KAAK,CACd,CAAC;;uFAEgF,CAAC,EAClF;YAAC;SAAU;IAEf,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,8CAA8C;IAC5D,qDAAqD;IACvD;AACF"}},
    {"offset": {"line": 199, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Leonardo%20Machado/Documents/Planeamento%20dental/planeamento-dental/src/lib/api-shared/sectionCompletion.ts"],"sourcesContent":["import pool from './db'\r\n\r\n/**\r\n * Calcula e persiste o completion_percent e status de uma seção do dossiê\r\n */\r\nexport async function updateSectionCompletion(\r\n  dossierId: string,\r\n  sectionCode: string,\r\n): Promise<void> {\r\n  // 1. Buscar section_id pelo code\r\n  const sectionResult = await pool.query(\r\n    'SELECT id FROM sections WHERE code = $1',\r\n    [sectionCode],\r\n  )\r\n\r\n  if (sectionResult.rows.length === 0) {\r\n    console.warn(`Seção ${sectionCode} não encontrada`)\r\n    return\r\n  }\r\n\r\n  const sectionId = sectionResult.rows[0].id\r\n\r\n  // 2. Calcular completion_percent base (required questions respondidas / total required)\r\n  const requiredQuestionsResult = await pool.query(\r\n    `SELECT COUNT(*) as total FROM questions q\r\n     JOIN question_sets qs ON qs.id = q.question_set_id\r\n     WHERE qs.section_id = $1 AND q.required = true`,\r\n    [sectionId],\r\n  )\r\n\r\n  const answeredResult = await pool.query(\r\n    `SELECT COUNT(*) as total FROM answers a\r\n     JOIN questions q ON q.id = a.question_id\r\n     JOIN question_sets qs ON qs.id = q.question_set_id\r\n     WHERE qs.section_id = $1 AND a.dossier_id = $2 \r\n     AND (a.value_text IS NOT NULL AND a.value_text != '' \r\n          OR a.value_number IS NOT NULL \r\n          OR a.value_json IS NOT NULL)`,\r\n    [sectionId, dossierId],\r\n  )\r\n\r\n  const totalRequired = parseInt(requiredQuestionsResult.rows[0].total)\r\n  const totalAnswered = parseInt(answeredResult.rows[0].total)\r\n\r\n  // Se não há perguntas required, considera 100% se não há perguntas, ou 0% se há mas nenhuma respondida\r\n  let completionPercent = 0\r\n  if (totalRequired === 0) {\r\n    // Verificar se há perguntas não-required respondidas\r\n    const allQuestionsResult = await pool.query(\r\n      `SELECT COUNT(*) as total FROM questions q\r\n       JOIN question_sets qs ON qs.id = q.question_set_id\r\n       WHERE qs.section_id = $1`,\r\n      [sectionId],\r\n    )\r\n    const totalQuestions = parseInt(allQuestionsResult.rows[0].total)\r\n    completionPercent = totalQuestions === 0 ? 100 : 0\r\n  } else {\r\n    completionPercent = Math.round((totalAnswered / totalRequired) * 100)\r\n  }\r\n\r\n  // 3. Aplicar bônus por entidades mínimas\r\n  if (sectionCode === 'IDENTITY') {\r\n    const segmentsResult = await pool.query(\r\n      'SELECT COUNT(*) as count FROM customer_segments WHERE dossier_id = $1 AND status = $2',\r\n      [dossierId, 'active'],\r\n    )\r\n    const propositionsResult = await pool.query(\r\n      'SELECT COUNT(*) as count FROM value_propositions WHERE dossier_id = $1 AND status = $2',\r\n      [dossierId, 'active'],\r\n    )\r\n\r\n    const hasSegments = parseInt(segmentsResult.rows[0].count) >= 1\r\n    const hasPropositions = parseInt(propositionsResult.rows[0].count) >= 1\r\n\r\n    if (hasSegments && hasPropositions) {\r\n      completionPercent = Math.min(100, completionPercent + 10)\r\n    } else if (hasSegments || hasPropositions) {\r\n      completionPercent = Math.min(100, completionPercent + 5)\r\n    }\r\n  } else if (sectionCode === 'MARKET') {\r\n    const competitorsResult = await pool.query(\r\n      'SELECT COUNT(*) as count FROM competitors WHERE dossier_id = $1 AND status = $2',\r\n      [dossierId, 'active'],\r\n    )\r\n    const hasCompetitors = parseInt(competitorsResult.rows[0].count) >= 1\r\n    if (hasCompetitors) {\r\n      completionPercent = Math.min(100, completionPercent + 10)\r\n    }\r\n  } else if (sectionCode === 'OFFER') {\r\n    const servicesResult = await pool.query(\r\n      'SELECT COUNT(*) as count FROM services WHERE dossier_id = $1 AND status = $2',\r\n      [dossierId, 'active'],\r\n    )\r\n    const hasServices = parseInt(servicesResult.rows[0].count) >= 1\r\n    if (hasServices) {\r\n      completionPercent = Math.min(100, completionPercent + 10)\r\n    }\r\n  } else if (sectionCode === 'OPERATIONS') {\r\n    const teamMembersResult = await pool.query(\r\n      'SELECT COUNT(*) as count FROM team_members WHERE dossier_id = $1 AND status = $2',\r\n      [dossierId, 'active'],\r\n    )\r\n    const capacitiesResult = await pool.query(\r\n      'SELECT COUNT(*) as count FROM capacities WHERE dossier_id = $1 AND status = $2',\r\n      [dossierId, 'active'],\r\n    )\r\n    const hasTeamMembers = parseInt(teamMembersResult.rows[0].count) >= 1\r\n    const hasCapacities = parseInt(capacitiesResult.rows[0].count) >= 1\r\n    if (hasTeamMembers || hasCapacities) {\r\n      completionPercent = Math.min(100, completionPercent + 10)\r\n    }\r\n  } else if (sectionCode === 'STRATEGY') {\r\n    const strategicChoicesResult = await pool.query(\r\n      'SELECT COUNT(*) as count FROM strategic_choices WHERE dossier_id = $1 AND status = $2',\r\n      [dossierId, 'active'],\r\n    )\r\n    const hasStrategicChoices = parseInt(strategicChoicesResult.rows[0].count) >= 1\r\n    if (hasStrategicChoices) {\r\n      completionPercent = Math.min(100, completionPercent + 10)\r\n    }\r\n  } else if (sectionCode === 'PLAN') {\r\n    const initiativesResult = await pool.query(\r\n      'SELECT COUNT(*) as count FROM initiatives WHERE dossier_id = $1 AND status = $2',\r\n      [dossierId, 'active'],\r\n    )\r\n    const hasInitiatives = parseInt(initiativesResult.rows[0].count) >= 1\r\n    if (hasInitiatives) {\r\n      completionPercent = Math.min(100, completionPercent + 10)\r\n    }\r\n  }\r\n\r\n  // 4. Determinar status baseado no completion_percent\r\n  let status: 'not_started' | 'in_progress' | 'complete'\r\n  if (completionPercent === 0) {\r\n    status = 'not_started'\r\n  } else if (completionPercent === 100) {\r\n    status = 'complete'\r\n  } else {\r\n    status = 'in_progress'\r\n  }\r\n\r\n  // 5. Persistir no banco\r\n  await pool.query(\r\n    `INSERT INTO dossier_sections_status (dossier_id, section_id, completion_percent, status, last_updated_at)\r\n     VALUES ($1, $2, $3, $4, NOW())\r\n     ON CONFLICT (dossier_id, section_id)\r\n     DO UPDATE SET \r\n       completion_percent = EXCLUDED.completion_percent,\r\n       status = EXCLUDED.status,\r\n       last_updated_at = NOW()`,\r\n    [dossierId, sectionId, completionPercent, status],\r\n  )\r\n}\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 349, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Leonardo%20Machado/Documents/Planeamento%20dental/planeamento-dental/pages/api/dossiers/%5Bid%5D/answers.ts"],"sourcesContent":["import type { VercelRequest, VercelResponse } from '@vercel/node'\r\nimport { authenticateToken, AuthRequest } from '@/lib/api-shared/auth'\r\nimport pool from '@/lib/api-shared/db'\r\nimport { markSectionReportsAsStale, getSectionForQuestion, markFinalReportAsStale } from '@/lib/api-shared/staleTracking'\r\nimport { updateSectionCompletion } from '@/lib/api-shared/sectionCompletion'\r\n\r\nexport default async function handler(\r\n  req: VercelRequest,\r\n  res: VercelResponse,\r\n) {\r\n  // CORS headers\r\n  res.setHeader('Access-Control-Allow-Credentials', 'true')\r\n  res.setHeader('Access-Control-Allow-Origin', '*')\r\n  res.setHeader(\r\n    'Access-Control-Allow-Methods',\r\n    'GET,OPTIONS,PATCH,DELETE,POST,PUT',\r\n  )\r\n  res.setHeader(\r\n    'Access-Control-Allow-Headers',\r\n    'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version, Authorization',\r\n  )\r\n\r\n  if (req.method === 'OPTIONS') {\r\n    res.status(200).end()\r\n    return\r\n  }\r\n\r\n  return authenticateToken(req as AuthRequest, res, async () => {\r\n    try {\r\n      const { method } = req\r\n      const authReq = req as AuthRequest\r\n      const user = authReq.user!\r\n      const dossierId = req.query.id as string\r\n      const sectionCode = req.query.sectionCode as string\r\n\r\n      if (!dossierId) {\r\n        return res.status(400).json({ error: 'ID do dossiê é obrigatório' })\r\n      }\r\n\r\n      // Validar acesso ao dossiê\r\n      const dossierResult = await pool.query(\r\n        'SELECT clinic_id FROM dossiers WHERE id = $1',\r\n        [dossierId],\r\n      )\r\n\r\n      if (dossierResult.rows.length === 0) {\r\n        return res.status(404).json({ error: 'Dossiê não encontrado' })\r\n      }\r\n\r\n      const clinicId = dossierResult.rows[0].clinic_id\r\n\r\n      if (user.role !== 'admin' && user.clinicId !== clinicId) {\r\n        return res.status(403).json({ error: 'Acesso negado a este dossiê' })\r\n      }\r\n\r\n      if (method === 'GET') {\r\n        // Obter respostas por seção ou todas\r\n        let query = `\r\n          SELECT a.*, q.code as question_code, q.text as question_text, q.type as question_type\r\n          FROM answers a\r\n          JOIN questions q ON q.id = a.question_id\r\n          WHERE a.dossier_id = $1\r\n        `\r\n        const params: any[] = [dossierId]\r\n\r\n        if (sectionCode) {\r\n          query += `\r\n            AND q.question_set_id IN (\r\n              SELECT qs.id FROM question_sets qs\r\n              JOIN sections s ON s.id = qs.section_id\r\n              WHERE s.code = $2\r\n            )\r\n          `\r\n          params.push(sectionCode)\r\n        }\r\n\r\n        query += ' ORDER BY q.order_index'\r\n\r\n        const result = await pool.query(query, params)\r\n        return res.status(200).json(result.rows)\r\n      }\r\n\r\n      if (method === 'POST') {\r\n        // Upsert de respostas (array)\r\n        const { answers } = req.body\r\n\r\n        if (!Array.isArray(answers)) {\r\n          return res.status(400).json({ error: 'answers deve ser um array' })\r\n        }\r\n\r\n        // Validar que todas as perguntas existem e pertencem ao dossiê\r\n        const questionIds = answers.map((a: any) => a.questionId).filter(Boolean)\r\n        if (questionIds.length === 0) {\r\n          return res.status(400).json({ error: 'Nenhuma pergunta válida fornecida' })\r\n        }\r\n\r\n        const questionsCheck = await pool.query(\r\n          'SELECT id, code, type FROM questions WHERE id = ANY($1::uuid[])',\r\n          [questionIds],\r\n        )\r\n\r\n        if (questionsCheck.rows.length !== questionIds.length) {\r\n          return res.status(400).json({ error: 'Uma ou mais perguntas não foram encontradas' })\r\n        }\r\n\r\n        // Processar cada resposta\r\n        const upsertPromises = answers.map(async (answer: any) => {\r\n          try {\r\n            const { questionId, valueText, valueNumber, valueJson, source } = answer\r\n\r\n            // Determinar qual campo usar baseado no tipo da pergunta\r\n            const question = questionsCheck.rows.find((q: any) => q.id === questionId)\r\n            if (!question) return null\r\n\r\n            let finalValueText = null\r\n            let finalValueNumber = null\r\n            let finalValueJson = null\r\n\r\n            if (question.type === 'number' || question.type === 'currency' || question.type === 'scale') {\r\n              finalValueNumber = valueNumber !== undefined ? valueNumber : (valueText ? parseFloat(valueText) : null)\r\n            } else if (question.type === 'json' || question.type === 'multi_select') {\r\n              // Para tipos JSON, priorizar valueJson\r\n              if (valueJson !== undefined && valueJson !== null) {\r\n                finalValueJson = valueJson\r\n              } else if (valueText) {\r\n                // Se tiver valueText, tentar fazer parse, mas capturar erro\r\n                try {\r\n                  finalValueJson = JSON.parse(valueText)\r\n                } catch (parseError) {\r\n                  // WORKAROUND: Para perguntas configuradas incorretamente como json/multi_select\r\n                  // mas que estão sendo usadas como textarea, salvar como texto mesmo\r\n                  console.warn(`⚠️ Pergunta ${question.code} é tipo ${question.type} mas recebeu texto simples. Salvando como value_text.`)\r\n                  finalValueText = valueText\r\n                  finalValueJson = null\r\n                }\r\n              } else {\r\n                finalValueJson = null\r\n              }\r\n            } else {\r\n              finalValueText = valueText !== undefined ? valueText : (valueNumber ? String(valueNumber) : null)\r\n            }\r\n\r\n            return pool.query(\r\n              `INSERT INTO answers (dossier_id, question_id, value_text, value_number, value_json, source, updated_at)\r\n               VALUES ($1, $2, $3, $4, $5, $6, NOW())\r\n               ON CONFLICT (dossier_id, question_id)\r\n               DO UPDATE SET\r\n                 value_text = EXCLUDED.value_text,\r\n                 value_number = EXCLUDED.value_number,\r\n                 value_json = EXCLUDED.value_json,\r\n                 source = EXCLUDED.source,\r\n                 updated_at = NOW()\r\n               RETURNING *`,\r\n              [dossierId, questionId, finalValueText, finalValueNumber, finalValueJson, source || 'user'],\r\n            )\r\n          } catch (error: any) {\r\n            // Log do erro específico mas não falhar toda a operação\r\n            console.error(`Erro ao processar resposta da pergunta ${answer.questionId}:`, error.message)\r\n            throw error // Re-throw para que o erro seja capturado no catch principal\r\n          }\r\n        })\r\n\r\n        const results = await Promise.all(upsertPromises.filter(Boolean))\r\n        const savedAnswers = results.map((r: any) => r.rows[0]).filter(Boolean)\r\n\r\n        // Marcar relatórios como stale para as seções afetadas\r\n        const affectedSections = new Set<string>()\r\n        for (const answer of savedAnswers) {\r\n          const sectionCode = await getSectionForQuestion(answer.question_id)\r\n          if (sectionCode) {\r\n            affectedSections.add(sectionCode)\r\n          }\r\n        }\r\n\r\n        // Se sectionCode foi fornecido, usar ele diretamente\r\n        if (sectionCode) {\r\n          affectedSections.add(sectionCode)\r\n        }\r\n\r\n        // Marcar todos os relatórios das seções afetadas como stale\r\n        for (const sectionCodeToMark of affectedSections) {\r\n          await markSectionReportsAsStale(dossierId, sectionCodeToMark)\r\n        }\r\n\r\n        // Marcar relatório final como stale se alguma seção foi afetada\r\n        if (affectedSections.size > 0) {\r\n          await markFinalReportAsStale(dossierId)\r\n        }\r\n\r\n        // Atualizar completude das seções afetadas\r\n        for (const sectionCodeToUpdate of affectedSections) {\r\n          await updateSectionCompletion(dossierId, sectionCodeToUpdate)\r\n        }\r\n\r\n        return res.status(200).json({ saved: savedAnswers.length, answers: savedAnswers })\r\n      }\r\n\r\n      return res.status(405).json({ error: 'Método não permitido' })\r\n    } catch (error: any) {\r\n      console.error('Erro na API de respostas:', error)\r\n      return res.status(500).json({ error: error.message })\r\n    }\r\n  })\r\n}\r\n\r\n"],"names":[],"mappings":"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"}}]
}