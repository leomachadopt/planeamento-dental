{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/Leonardo%20Machado/Documents/Planeamento%20dental/planeamento-dental/src/lib/api-shared/auth.ts"],"sourcesContent":["import type { VercelRequest, VercelResponse } from '@vercel/node'\r\nimport jwt from 'jsonwebtoken'\r\n\r\nexport interface AuthRequest extends VercelRequest {\r\n  user?: {\r\n    id: string\r\n    email: string\r\n    role: 'admin' | 'user'\r\n    clinicId?: string\r\n    name: string\r\n  }\r\n}\r\n\r\n// Usar variável de ambiente ou fallback\r\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production'\r\n\r\nif (!process.env.JWT_SECRET) {\r\n  console.warn('⚠️  JWT_SECRET não configurado! Usando valor padrão inseguro.')\r\n}\r\n\r\nexport function authenticateToken(\r\n  req: AuthRequest,\r\n  res: VercelResponse,\r\n  next: () => void\r\n) {\r\n  const authHeader = req.headers['authorization']\r\n  const token = authHeader && authHeader.split(' ')[1]\r\n\r\n  if (!token) {\r\n    return res.status(401).json({ error: 'Token não fornecido' })\r\n  }\r\n\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET) as AuthRequest['user']\r\n    req.user = decoded\r\n    next()\r\n  } catch (error) {\r\n    return res.status(403).json({ error: 'Token inválido ou expirado' })\r\n  }\r\n}\r\n\r\nexport function requireAdmin(\r\n  req: AuthRequest,\r\n  res: VercelResponse,\r\n  next: () => void\r\n) {\r\n  if (req.user?.role !== 'admin') {\r\n    return res.status(403).json({ error: 'Acesso negado. Admin necessário.' })\r\n  }\r\n  next()\r\n}\r\n\r\nexport function optionalAuth(\r\n  req: AuthRequest,\r\n  res: VercelResponse,\r\n  next: () => void\r\n) {\r\n  const authHeader = req.headers['authorization']\r\n  const token = authHeader && authHeader.split(' ')[1]\r\n\r\n  if (token) {\r\n    try {\r\n      const decoded = jwt.verify(token, JWT_SECRET) as AuthRequest['user']\r\n      req.user = decoded\r\n    } catch (error) {\r\n      // Token inválido, mas continua sem autenticação\r\n    }\r\n  }\r\n  next()\r\n}\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":";;;;;;;;AACA;;AAYA,wCAAwC;AACxC,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAE7C,IAAI,CAAC,QAAQ,GAAG,CAAC,UAAU,EAAE;IAC3B,QAAQ,IAAI,CAAC;AACf;AAEO,SAAS,kBACd,GAAgB,EAChB,GAAmB,EACnB,IAAgB;IAEhB,MAAM,aAAa,IAAI,OAAO,CAAC,gBAAgB;IAC/C,MAAM,QAAQ,cAAc,WAAW,KAAK,CAAC,IAAI,CAAC,EAAE;IAEpD,IAAI,CAAC,OAAO;QACV,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAAsB;IAC7D;IAEA,IAAI;QACF,MAAM,UAAU,wRAAG,CAAC,MAAM,CAAC,OAAO;QAClC,IAAI,IAAI,GAAG;QACX;IACF,EAAE,OAAO,OAAO;QACd,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAA6B;IACpE;AACF;AAEO,SAAS,aACd,GAAgB,EAChB,GAAmB,EACnB,IAAgB;IAEhB,IAAI,IAAI,IAAI,EAAE,SAAS,SAAS;QAC9B,OAAO,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;YAAE,OAAO;QAAmC;IAC1E;IACA;AACF;AAEO,SAAS,aACd,GAAgB,EAChB,GAAmB,EACnB,IAAgB;IAEhB,MAAM,aAAa,IAAI,OAAO,CAAC,gBAAgB;IAC/C,MAAM,QAAQ,cAAc,WAAW,KAAK,CAAC,IAAI,CAAC,EAAE;IAEpD,IAAI,OAAO;QACT,IAAI;YACF,MAAM,UAAU,wRAAG,CAAC,MAAM,CAAC,OAAO;YAClC,IAAI,IAAI,GAAG;QACb,EAAE,OAAO,OAAO;QACd,gDAAgD;QAClD;IACF;IACA;AACF"}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/Leonardo%20Machado/Documents/Planeamento%20dental/planeamento-dental/src/lib/api-shared/db.ts"],"sourcesContent":["// Módulo compartilhado para API routes\r\n// Este arquivo só roda no servidor (Node.js)\r\n\r\nimport { Pool } from 'pg'\r\n\r\n// Validar DATABASE_URL\r\nif (!process.env.DATABASE_URL) {\r\n  console.error('❌ DATABASE_URL não está configurada!')\r\n  console.error('❌ Configure DATABASE_URL no arquivo .env.local ou nas variáveis de ambiente')\r\n  throw new Error('DATABASE_URL não configurada. Configure no .env.local ou variáveis de ambiente.')\r\n}\r\n\r\n// Pool de conexões PostgreSQL\r\nconst pool = new Pool({\r\n  connectionString: process.env.DATABASE_URL,\r\n  ssl: {\r\n    rejectUnauthorized: false,\r\n  },\r\n  max: 20,\r\n  idleTimeoutMillis: 30000,\r\n  connectionTimeoutMillis: 2000,\r\n})\r\n\r\npool.on('connect', () => {\r\n  console.log('✅ Conectado ao banco de dados Neon')\r\n})\r\n\r\npool.on('error', (err) => {\r\n  console.error('❌ Erro no pool de conexões:', err)\r\n})\r\n\r\nexport default pool\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":";;;;AAAA,uCAAuC;AACvC,6CAA6C;AAE7C;;;;;;AAEA,uBAAuB;AACvB,IAAI,CAAC,QAAQ,GAAG,CAAC,YAAY,EAAE;IAC7B,QAAQ,KAAK,CAAC;IACd,QAAQ,KAAK,CAAC;IACd,MAAM,IAAI,MAAM;AAClB;AAEA,8BAA8B;AAC9B,MAAM,OAAO,IAAI,qPAAI,CAAC;IACpB,kBAAkB,QAAQ,GAAG,CAAC,YAAY;IAC1C,KAAK;QACH,oBAAoB;IACtB;IACA,KAAK;IACL,mBAAmB;IACnB,yBAAyB;AAC3B;AAEA,KAAK,EAAE,CAAC,WAAW;IACjB,QAAQ,GAAG,CAAC;AACd;AAEA,KAAK,EAAE,CAAC,SAAS,CAAC;IAChB,QAAQ,KAAK,CAAC,+BAA+B;AAC/C;uCAEe"}},
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"sources":["file:///mnt/c/Users/Leonardo%20Machado/Documents/Planeamento%20dental/planeamento-dental/pages/api/dossiers/%5Bid%5D/sections.ts"],"sourcesContent":["import type { VercelRequest, VercelResponse } from '@vercel/node'\r\nimport { authenticateToken, AuthRequest } from '@/lib/api-shared/auth'\r\nimport pool from '@/lib/api-shared/db'\r\n\r\nexport default async function handler(\r\n  req: VercelRequest,\r\n  res: VercelResponse,\r\n) {\r\n  // CORS headers\r\n  res.setHeader('Access-Control-Allow-Credentials', 'true')\r\n  res.setHeader('Access-Control-Allow-Origin', '*')\r\n  res.setHeader(\r\n    'Access-Control-Allow-Methods',\r\n    'GET,OPTIONS,PATCH,DELETE,POST,PUT',\r\n  )\r\n  res.setHeader(\r\n    'Access-Control-Allow-Headers',\r\n    'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version, Authorization',\r\n  )\r\n\r\n  if (req.method === 'OPTIONS') {\r\n    res.status(200).end()\r\n    return\r\n  }\r\n\r\n  return authenticateToken(req as AuthRequest, res, async () => {\r\n    try {\r\n      const { method } = req\r\n      const authReq = req as AuthRequest\r\n      const user = authReq.user!\r\n      const dossierId = req.query.id as string\r\n      const sectionCode = req.query.sectionCode as string\r\n\r\n      if (!dossierId) {\r\n        return res.status(400).json({ error: 'ID do dossiê é obrigatório' })\r\n      }\r\n\r\n      // Validar acesso ao dossiê\r\n      const dossierResult = await pool.query(\r\n        'SELECT clinic_id FROM dossiers WHERE id = $1',\r\n        [dossierId],\r\n      )\r\n\r\n      if (dossierResult.rows.length === 0) {\r\n        return res.status(404).json({ error: 'Dossiê não encontrado' })\r\n      }\r\n\r\n      const clinicId = dossierResult.rows[0].clinic_id\r\n\r\n      if (user.role !== 'admin' && user.clinicId !== clinicId) {\r\n        return res.status(403).json({ error: 'Acesso negado a este dossiê' })\r\n      }\r\n\r\n      if (method === 'GET') {\r\n        if (sectionCode) {\r\n          // Carregar dados completos de uma seção específica\r\n          const sectionResult = await pool.query(\r\n            'SELECT * FROM sections WHERE code = $1',\r\n            [sectionCode],\r\n          )\r\n\r\n          if (sectionResult.rows.length === 0) {\r\n            return res.status(404).json({ error: 'Seção não encontrada' })\r\n          }\r\n\r\n          const section = sectionResult.rows[0]\r\n\r\n          // Buscar status da seção\r\n          const statusResult = await pool.query(\r\n            `SELECT * FROM dossier_sections_status \r\n             WHERE dossier_id = $1 AND section_id = $2`,\r\n            [dossierId, section.id],\r\n          )\r\n\r\n          const sectionStatus = statusResult.rows[0] || {\r\n            status: 'not_started',\r\n            completion_percent: 0,\r\n          }\r\n\r\n          // Buscar question_sets ativos da seção (apenas a versão mais recente de cada)\r\n          const questionSetsResult = await pool.query(\r\n            `SELECT DISTINCT ON (qs.subsection_id, qs.section_id)\r\n             qs.*, sub.code as subsection_code, sub.name as subsection_name\r\n             FROM question_sets qs\r\n             LEFT JOIN subsections sub ON sub.id = qs.subsection_id\r\n             WHERE qs.section_id = $1 AND qs.is_active = true\r\n             ORDER BY qs.subsection_id, qs.section_id, qs.version DESC`,\r\n            [section.id],\r\n          )\r\n\r\n          // Para cada question_set, buscar perguntas e respostas\r\n          const questionSetsWithData = await Promise.all(\r\n            questionSetsResult.rows.map(async (qs) => {\r\n              const questionsResult = await pool.query(\r\n                `SELECT q.*, \r\n                 json_agg(\r\n                   json_build_object('id', qo.id, 'label', qo.label, 'value', qo.value, 'order_index', qo.order_index)\r\n                   ORDER BY qo.order_index\r\n                 ) FILTER (WHERE qo.id IS NOT NULL) as options\r\n                 FROM questions q\r\n                 LEFT JOIN question_options qo ON qo.question_id = q.id\r\n                 WHERE q.question_set_id = $1\r\n                 GROUP BY q.id\r\n                 ORDER BY q.order_index`,\r\n                [qs.id],\r\n              )\r\n\r\n              // Buscar respostas para estas perguntas\r\n              const questionIds = questionsResult.rows.map((q: any) => q.id)\r\n              let answers: any[] = []\r\n\r\n              if (questionIds.length > 0) {\r\n                const answersResult = await pool.query(\r\n                  `SELECT * FROM answers \r\n                   WHERE dossier_id = $1 AND question_id = ANY($2::uuid[])`,\r\n                  [dossierId, questionIds],\r\n                )\r\n                answers = answersResult.rows\r\n              }\r\n\r\n              // Mapear respostas por question_id\r\n              const answersMap = new Map(answers.map((a) => [a.question_id, a]))\r\n\r\n              const questions = questionsResult.rows.map((q: any) => ({\r\n                ...q,\r\n                options: q.options || [],\r\n                answer: answersMap.get(q.id) || null,\r\n              }))\r\n\r\n              return {\r\n                ...qs,\r\n                questions,\r\n              }\r\n            }),\r\n          )\r\n\r\n          // Buscar entidades relacionadas à seção (se for Identidade)\r\n          let entities: any = {}\r\n          if (sectionCode === 'IDENTITY') {\r\n            const segmentsResult = await pool.query(\r\n              'SELECT * FROM customer_segments WHERE clinic_id = $1 AND dossier_id = $2 ORDER BY priority, created_at',\r\n              [clinicId, dossierId],\r\n            )\r\n            entities.customerSegments = segmentsResult.rows\r\n\r\n            const propositionsResult = await pool.query(\r\n              `SELECT vp.*, cs.name as target_segment_name\r\n               FROM value_propositions vp\r\n               LEFT JOIN customer_segments cs ON cs.id = vp.target_segment_id\r\n               WHERE vp.clinic_id = $1 AND vp.dossier_id = $2\r\n               ORDER BY vp.created_at`,\r\n              [clinicId, dossierId],\r\n            )\r\n            entities.valuePropositions = propositionsResult.rows\r\n          }\r\n\r\n          return res.status(200).json({\r\n            section,\r\n            status: sectionStatus,\r\n            questionSets: questionSetsWithData,\r\n            entities,\r\n          })\r\n        } else {\r\n          // Listar todas as seções com status\r\n          const sectionsResult = await pool.query(\r\n            `SELECT s.*, \r\n             COALESCE(dss.status, 'not_started') as status,\r\n             COALESCE(dss.completion_percent, 0) as completion_percent,\r\n             dss.last_updated_at\r\n             FROM sections s\r\n             LEFT JOIN dossier_sections_status dss ON dss.section_id = s.id AND dss.dossier_id = $1\r\n             ORDER BY s.order_index`,\r\n            [dossierId],\r\n          )\r\n\r\n          return res.status(200).json(sectionsResult.rows)\r\n        }\r\n      }\r\n\r\n      return res.status(405).json({ error: 'Método não permitido' })\r\n    } catch (error: any) {\r\n      console.error('Erro na API de seções:', error)\r\n      return res.status(500).json({ error: error.message })\r\n    }\r\n  })\r\n}\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":"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"}}]
}